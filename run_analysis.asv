% =========================================================================
% Practical 1: 2D Convolution Analysis
% =========================================================================
%
% GROUP NUMBER: 6
%
% MEMBERS:
%   - Member 1 Michael Lighton, LGHMIC003
%   - Member 2 Glen Jones, JNSGLE007


%% ========================================================================
%  PART 1: Manual 2D Convolution Implementation
%  ========================================================================
%
% REQUIREMENT: You may NOT use built-in convolution functions (conv2, imfilter, etc.)

% TODO: Implement manual 2D convolution using Sobel Operator(Gx and Gy)
% output - Convolved image result (grayscale)
function output = my_conv2(image, Gx, Gy, output_mode) %Add necessary input arguments

    grey_image = double(rgb2gray(image));

    % Get dimensions of the grayscale image
    [rows, cols] = size(grey_image);
    [kernel_Row, kernel_Col] = size(Gx);

    % Padding based on mode
    switch lower(output_mode)
        case 'full'
            padRow = kernel_Row - 1; 
            padCol = kernel_Col - 1;

        case 'same'
            padRow = floor(kernel_Row/2);
            padCol = floor(kernel_Col/2);

        case 'valid'
            padRow = 0;
            padCol = 0;
    end
    
    % Pad the image to handle borders
    paddedImage = padarray(grey_image, [padRow padCol], 0);
    
    % Initialize gradients
    gradient_x = zeros(rows, cols); % Intialize x gradient to all 0s
    gradient_y = zeros(rows, cols); % Intialize y gradient to all 0s
    
    % Perform convolution
    for i = 1:rows % Loop through rows
        for j = 1:cols % Loop through columns
            region = paddedImage(i:i+2, j:j+2); % Extracts the 3x3 region around the current pixel
            gradient_x(i, j) = sum(sum(region .* Gx)); % Performs convolution with Gx
            gradient_y(i, j) = sum(sum(region .* Gy)); % Performs convolution with Gx
        end
    end
    
    % Combine results from Gx and Gy for final output
    output = sqrt(gradient_x.^2 + gradient_y.^2); % Magnitude of gradients
end

%% ========================================================================
%  PART 2: Built-in 2D Convolution Implementation
%  ========================================================================
%   
% REQUIREMENT: You MUST use the built-in conv2 function

% TODO: Use conv2 to perform 2D convolution
% output - Convolved image result (grayscale)
function output = inbuilt_conv2(varargin) %Add necessary input arguments

end


%% ========================================================================
%  PART 3: Testing and Analysis
%  ========================================================================
%
% Compare the performance of manual 2D convolution (my_conv2) with MATLAB's
% built-in conv2 function (inbuilt_conv2).

function run_analysis()
    % TODO1:
    % Load all the sample images from the 'sample_images' folder
    images{1} = imread('image_128x128.png');
    images{2} = imread('image_256x256.png');
    images{3} = imread('image_512x512.png');
    images{4} = imread('image_1024x1024.png');
    images{5} = imread('image_2048x2048.png');

    image_names = {'image_128x128', 'image_256x256', 'image_512x512', 'image_1024x1024', 'image_2048x2048'};
    
    % TODO2:
    % Define edge detection kernels (Sobel kernel)
    Gx = [-1 0 1; -2 0 2; -1 0 1]; % Sobel kernel for x-direction
    Gy = [1 2 1; 0 0 0; -1 -2 -1]; % Sobel kernel for y-direction
 

    % TODO3:
    % For each image, perform the following:
    for k = 1:length(images)
        %   a. Measure execution time of my_conv2
        tic;
        manual_output = my_conv2(images{k},Gx,Gy,'full');
        time_manual = toc;
        %   b. Measure execution time of inbuilt_conv2
        tic;
        in_built_output = inbuilt_conv2(images{k},Gx,Gy,'full');
        time_builtin = toc;
        %   c. Compute speedup ratio
        speed_up_ratio = 
        %   d. Verify output correctness (compare results)
        %   e. Store results (image name, time_manual, time_builtin, speedup)
        %   f. Plot and compare results
        %   g. Visualise the edge detection results(Optional)
    end
    
    
end
